# Hardware Development Log: Traction System & Architecture

This document details the development journey of the traction system for the Orin Mecanum Rover, covering mechanical adaptations, electrical challenges with voltage logic, and the final architectural decision to implement a distributed computing model using an Arduino Nano as a dedicated hardware controller.

## 1. Mechanical Assembly: Motor Adaptation
The propulsion system is based on four **JGB37-520 DC Motors** equipped with metal gearboxes and Hall effect quadrature encoders.

* **Challenge:** A mechanical mismatch occurred between the motor shafts and the mecanum wheel couplings. The JGB37-520 motors feature a **6.5mm D-shaft**, whereas the sourced wheel couplings were designed for a standard **6mm** shaft.
* **Solution:** Rather than sourcing new motors or couplings, we modified the existing couplings. Using a **lathe**, the internal bore of each coupling was precisely machined from 6mm to 6.5mm to ensure a tight, concentric fit, preventing wobble during rotation.

## 2. Electrical System & Signal Logic

### 2.1 The Encoder Voltage Problem
The integration of the motor encoders with the **NVIDIA Jetson Orin Nano** presented significant electrical hurdles regarding logic levels and signal integrity.

* **Initial Testing (3.3V Logic):** Initially, the encoders were powered via the Jetson's 3.3V rail to match the Orin Nano's GPIO logic level. However, testing revealed unstable results: the ticks were erratic, scattered, and inaccurate at low speeds. This was due to the internal circuitry of the 520 motors (designed for 5V) failing to produce a clean square wave at 3.3V, resulting in "floating" signal states.
* **The 5V Dilemma:** Powering the encoders with an external 5V source immediately stabilized the readings, providing accurate high-resolution feedback. However, this created a critical risk: the feedback signals (Phase A and Phase B) were now 5V logic. Connecting these directly to the Jetson Orin Nano (which is strictly **3.3V tolerant**) would permanently damage the GPIO pins.

### 2.2 The Driver Limitation
The system uses **BTS7960** high-power drivers controlled by a **PCA9685** PWM driver board.
* **Limitation:** While the PCA9685 is excellent for generating PWM signals to control motor speed via I2C, it is an **output-only device**. It lacks input capabilities and cannot read the high-frequency interrupt signals generated by the encoders.

## 3. Architectural Pivot: Master-Slave Configuration

To solve the voltage mismatch and the lack of real-time input handling, the architecture was redesigned to offload low-level hardware tasks to a microcontroller.

### 3.1 The Intermediate Microcontroller (Arduino Nano)
An **Arduino Nano (V3/ATmega328P)** was introduced as a middleware controller.
* **Role:** The Arduino operates natively at **5V**, making it the perfect interface for the encoders. It reads the raw encoder interrupts in real-time without risking hardware damage.
* **Motor Control:** The Arduino also takes over the command of the PCA9685 via I2C, centralizing all "locomotion" tasks.

### 3.2 Logic Level Conversion (LLC)
While the Arduino solves the encoder reading, it still needs to communicate with the 3.3V Jetson.
* **Solution:** A **Bi-Directional Logic Level Converter (LLC)** was inserted between the Arduino and the Jetson. This module safely steps down the Arduino's 5V transmission signals to 3.3V for the Jetson, and steps up the Jetson's 3.3V signals to 5V for the Arduino.

## 4. Communication Protocols

The final system uses a robust separation of concerns, utilizing distinct protocols for different layers of the stack:

### 4.1 Jetson ↔ Arduino: UART (Universal Asynchronous Receiver-Transmitter)
Instead of consuming a valuable USB/USBC port on the Jetson, communication is established via the physical GPIO header using the **UART** protocol.
* **Physical Layer:** Jetson UART pins (TX/RX) ↔ LLC ↔ Arduino UART pins (RX/TX).
* **Function:** The Jetson acts as the "High-Level Brain" (running ROS2/Navigation), sending velocity commands (e.g., linear `x`, `y`, angular `z`) to the Arduino. The Arduino acts as the "Low-Level Driver," replying with odometry data (encoder ticks).

### 4.2 Arduino ↔ PCA9685: I2C (Inter-Integrated Circuit)
* **Physical Layer:** Arduino A4 (SDA) / A5 (SCL) ↔ PCA9685.
* **Function:** The Arduino acts as the I2C Master. It calculates the required PWM duty cycle based on the PID control loop and sends the command to the PCA9685 to physically drive the motors.

